import { expect } from "chai";
import { ethers } from "hardhat";
import { BrandNFT, BrandStore } from "../typechain-types";

describe("NFTMarket", async function () {
  it("Should create and execute store sales", async function () {
    let brandStore: BrandStore;
    const signers = await ethers.getSigners();

    const brandStoreFactory = await ethers.getContractFactory(
      "BrandStore",
      signers[0]
    );
    brandStore = await brandStoreFactory.deploy();
    await brandStore.deployed();
    const marketAddress = brandStore.address;

    let brandNFT: BrandNFT;
    const brandTokenFactory = await ethers.getContractFactory(
      "BrandNFT",
      signers[0]
    );
    brandNFT = await brandTokenFactory.deploy(marketAddress);
    await brandNFT.deployed();
    const brandTokenAddress = brandNFT.address;

    let listingPrice = await brandStore.getListingPrice();

    console.log(`Listing price`, listingPrice.toString());

    // Create a value for the auction price of each item (in MATIC)
    const auctionPrice = ethers.utils.parseUnits("1", "ether");

    // Create two Brand NFTs and put them for sale
    let token1 = await brandNFT.createToken("https://www.mytokenlocation.com");
    let token2 = await brandNFT.createToken("https://www.mytokenlocation2.com");
    let token3 = await brandNFT.createToken("https://www.mytokenlocation3.com");
    console.log(`Brand NFT 1: `, token1);
    console.log(`Brand NFT 2: `, token2);
    console.log(`Brand NFT 3: `, token3);
    console.log(`\n`);

    await brandStore.createBrandItem(brandTokenAddress, 1, auctionPrice, {
      value: listingPrice,
    });
    await brandStore.createBrandItem(brandTokenAddress, 2, auctionPrice, {
      value: listingPrice,
    });
    await brandStore.createBrandItem(brandTokenAddress, 3, auctionPrice, {
      value: listingPrice,
    });
    /**
     *  Create Market Sale - execute a sale of a token to another user
     *    Fetching addresses from different users with getSigners()
     *      Real app -> user will use metamask and interact from an address
     *      Test environment -> reference to test accounts generated by hardhat
     *        When running our hardhat node, we work with the first address by default in an array of 20 test accounts
     *        [_,buyerAddress, thirdAddress] with _ the first address or address of the seller
     * */
    const [sellerAddress, buyerAddress] = await ethers.getSigners();

    await brandStore
      .connect(buyerAddress)
      .createMarketSale(brandTokenAddress, 1, { value: auctionPrice });

    await brandStore
      .connect(buyerAddress)
      .createMarketSale(brandTokenAddress, 2, { value: auctionPrice });

    /**
     * Fetching My NFTs - Query and return purchased NFTs of the user sending the transaction
     *    We already bought something with the buyer address. So we can use that to send the transaction from and check if it holds the NFT it has bought.
     */
    let myNFTs = await brandStore.connect(buyerAddress).fetchMyNFTs();
    console.log(`\n`);
    let humanReadableNFTs = await Promise.all(
      myNFTs.map(async (i): Promise<any> => {
        const tokenUri = await brandNFT.tokenURI(i.tokenId);
        let item = {
          price: i.price.toString(),
          tokenId: i.tokenId.toString(),
          seller: i.seller,
          owner: i.owner,
          tokenUri,
        };
        return item;
      })
    );
    console.log(`NFTs of buyer ${buyerAddress.address} \n`, humanReadableNFTs);
    console.log(`\n`);
    /**
     * Fetching Brand Items - Query for and return the unsold items
     *    To make the items more human readable in our console we map over all of the items and update the value of them
     *    We kinda prepare for the output we need to have on the frontend of our application
     *    We use Promise.all for asynchronous mapping
     * */
    let unsoldItems = await brandStore.fetchBrandItems();

    let humanReadableItems = await Promise.all(
      unsoldItems.map(async (i): Promise<any> => {
        const tokenUri = await brandNFT.tokenURI(i.tokenId);
        let item = {
          price: i.price.toString(),
          tokenId: i.tokenId.toString(),
          seller: i.seller,
          owner: i.owner,
          tokenUri,
        };
        return item;
      })
    );
    console.log(
      `Unsold Brand Items of Brand Owner ${sellerAddress.address}`,
      humanReadableItems
    );

    /**
     * Fetch Brand Items Created - Query and return brand items created by a user (in this case the brand itself)
     */
    let createdItems = await brandStore.fetchBrandItemsCreated();
    let humanReadableCreatedItems = await Promise.all(
      createdItems.map(async (i): Promise<any> => {
        const tokenUri = await brandNFT.tokenURI(i.tokenId);
        let item = {
          price: i.price.toString(),
          tokenId: i.tokenId.toString(),
          seller: i.seller,
          owner: i.owner,
          tokenUri,
        };
        return item;
      })
    );
    console.log(
      `Created Brand Items by the Brand Owner ${sellerAddress.address}`,
      humanReadableCreatedItems
    );
  });
});
